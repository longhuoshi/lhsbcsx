

/**
 * 跳转到指定类
 * {@link com.wld.java.MyMain}
 * <p>
 * 跳转到指定类的指定方法，下面4种都可以
 * {@link com.wld.java.MyMain#test(String)}
 * {@link com.wld.java.MyMain#test}
 *
 * @see com.wld.java.MyMain#test(String)
 * @see com.wld.java.MyMain#test
 */


===================================================page 399

14、章类型信息。
运行时类型信息使得你可以在程序运行时发现和使用类型信息。
它使你从只能在编译期执行面向类型的操作的禁锢中解脱出来，并且可以使用某些非常
强大的程序 ，对RTTI的需要，揭示了面向对象设计中许多有趣（并且复杂）的问题，同时也提
出了如何组织程序的问题。
	本章讨论java是如何让我们在运行时识别对象和类的信息的。主要有两种方式：
一种是“传统的”RTTI，它假定我们在编译时已经知道了所有的类型；
另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。
14.1、为什么需要RTTI？
bcsx.typeinfo  Shapes.java
	在这个例子中，当把Shape对象放入List<Shqpe>的数组时会向上转型。但在向上转型为
Shape的时候也丢失了Shape对象的具体类型。对于数组而言，它们只是Shape类的对象。
	当从数组中取出元素时，这种容器————实际上它将所有的事物都当作Object持有————会自动
将结果转型回Shape。这是RTTI最基本的使用形式，因为在java中，所有的类型转换都是在运行
时进行正确性检查的。这也是RTTI名字的含义：在运行时，识别一个对象的类型。
	在这个例子中，RTTI类型转换并不彻底：Object被转型为Shape，而不是为Circle、
Square或者Triangle。这是因为目前我们只知道这个List<Shape>保存的都是Shape。在编译时，
将由容器和Java的泛型系统来强制确保这一点；而在运行时，由类型转换操作来确保这一点。
	例如，假设我们允许用户将某一具体类型的几何形状全都变成某种特殊的颜色，以突出显示它们。
	使用RTTI，可以查询某个Shape引用所指向的对象的确切类型，然后选择或者剔除特例。

13章，字符串。
13.5格式化输出。
13.6 正则表达式
13.6.1基础
13.6.4 Pattern和Matcher
组（Groups）
组是用括号划分的表达式，可以根据组的编号来引用某个组。组号为0表示整个表达式，组号1表示被第一对括号括起的组，
依此类推。因此，在下面这个表达式 A(B(C))D中有三组：组0是ABCD,组1是BC,组2是C。

13.7.2 用正则表达式扫描。

14.2.1 类字面常量
14.2.2 泛化的Class引用。

14.2.3 新的转型语法
14.3 类型转换前先做检查。
14.3.1 使用类字面常量。
14.3.2 动态的instanceof。
14.3.3 递归计数
14.4 注册工厂
14.5 instanceof和Class的等价性。
14.6 反射：运行时的类信息
14.6.1 类方法提取器
14.7 动态代理。
14.8 空对象
14.8.1 模拟对象与桩
14.9 接口与类型信息。
15章 泛型
15.1与C++的比较
15.2简单泛型
15.2.1一个元组类库。
15.2.2一个堆栈类
15.2.3RandomList
15.3泛型接口
15.4泛型方法
15.4.1杠杆利用类型参数推断
15.4.2可变参数与泛型方法。
15.4.3用于Generator的泛型方法
15.4.4一个通用的Generator
15.4.5简化元组的使用。 399
15.4.6 一个Set实用工具。 400
15.5 匿名内部类 402
15.6构建复杂模型
15.7擦除的神秘之处 406
15.7.1C++方式
15.7.2迁移兼容性
15.7.3擦除的问题 409
15.7.4边界处的动作。
15.8擦除的补偿
15.8.1 创建类型实例。
InstantiateGenericType
FactoryConstraint
15.8.2 泛型数组。 416
15.9 边界   419
15.10 通配符
15.10.1 编译器有多聪明 425
15.10.2 逆变
15.10.3 无界通配符 428
15.10.4 捕获转换 432
15.11 问题  433
15.11.1 任何基本类型都不能作为类型参数
15.11.2 实现参数化接口  434
    一个类不能实现同一个泛型接口的两种变体 。由于擦除原因，这两种变体 会变成相同的接口。
15.11.3 转型和警告
15.11.4 重载 		436
15.11.5 基类劫持了接口
15.12  自限定的类型。
    在java泛型中，有一个好像是经常性出现的惯用法，它相当令人费解：
    class SelfBounded<T extends SelfBounded<T>>{ //...
   这就像两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射，SelfBounded类接受泛型参数T，
   而T由一个边界类限定，这个边界就是拥有T作为其参数的SelfBounded。
15.12.1 古怪的循环泛型。 437
15.12.2 自限定
15.12.3 参数协变 441
15.13 动态类型安全
15.14 导常
15.15 混型
15.15.2 与接口混合
15.15.3 使用装饰器模式。447
15.15.4 与动态代理混合
15.16 潜在类型机制 449
15.17 对缺乏潜在类型机制的补尝 453
15.17.1 反射
15.17.2 将一个方法应用于序列 455
15.17.3 当你并未碰巧拥有正确的接口时
15.17.4 用适配器仿真潜在类型机制
15.18 将函数对象用作策略 460
15.19 总结：转型真的如此之糟吗？

16章 数组
16.1 数组为什么特殊 467
16.2 数组是第一级对象
16.3 返回一个数组 470
16.4 多维数组
16.5 数组与泛型
16.6 创建测试数据  475
16.6.2 数据生成器 479
16.6.3 从Generator中创建数组
16.7 Arrays实用功能
16.7.1 复制数组
16.7.2 数组的比较
16.7.3 数组元素的比较.
16.7.4 数组排序.
16.7.5 在已排序的数组中查找 489

第17章 容器深入研究
17.1 完整的容器分类法
17.2 填充容器  493
17.2.1 一种Generator解决方案
17.2.2 Map生成器
17.3 Collection的功能方法
17.4.1 未获支持的操作  506
17.5 List的功能方法
17.6 Set和存储顺序  512
17.6.1 SortedSet
17.7 队列
 17.7.1 优先级队列
17.7.2 双向队例 515
17.8 理解Map	517
17.8.1 性能
17.8.2 SortedMap
17.8.3 LinkedHashMap
17.9 散列与散列码
17.9.1 理解hashCode()   523
17.9.3 覆盖hashCode()  529
17.10 选择接口的不同实现
17.10.1 性能测试框架  535
17.10.3 微基准测试的危险 540
17.10.4 对Set的选择  541
17.10.5 对Map的选择 542
17.11 实用方法   546
17.11.1 List的排序与查询 547
17.11.3 Collection或Map的同步控制
17.12 持有引用  552



























