D:\javaxxz\javaEE\【No1417】大厂面试之JUC并发编程与源码分析教程\
jucbase java高级技术JUC高并发编程

多线程操作步骤
1、 创建资源类，在资源类创建属性和方法。
2、在资源类操作方法
    判断->干活->通知 。
3、创建多个线程，调用 资源类中的操作方法。
4、防止虚假唤醒问题。


08-JUC高并发编程-线程间通信-概述和案例分析.mp4
12-JUC高并发编程-线程间定制化通信-案例分析
示例
启动三个线程，按照如下要求
AA打印5次，BB打印10次，CC打印15次
AA打印5次，BB打印10次，CC打印15次
进行10轮

解：
定义 一个标致位flag
1、AA线程 判断flag=1，打印5次。修改标致位flag=2，通知BB
2、BB线程 判断flag=2，打印5次。修改标致位flag=3，通知CC
3、CC线程 判断flag=3，打印5次。修改标致位flag=1，通知AA

13-JUC高并发编程-线程间定制化通信-案例实现
14-JUC高并发编程-集合线程安全-异常演示
16-JUC高并发编程-集合线程安全-ArrayList线程不安全和解决方案（二）
17-JUC高并发编程-集合线程安全-HashSet和HashMap线程不安全
18-JUC高并发编程-多线程锁-Synchronized锁的八种情况
19-JUC高并发编程-多线程锁-公平锁和非公平锁
非公平锁:线程饿死
        效率高
公平锁：阳光普照
       效率相对低。
       new ReentrantLock(true)

21-JUC高并发编程-多线程锁-可重入锁（2）
22-JUC高并发编程-多线程锁-死锁
两个或两个以上的进程(线程)在执行过程中，因为争夺资源而造 成一种互相等待的现象 ，
如果 没有外力干涉，他们无法再执行下去 。
产生死锁原因：
第一 系统资源不足
第二 进程运行推进顺序不合适
第三 资源分配不当。

 验证是否是死锁？
 1) jps  类似linux ps -ef   查看程序对应的进程 id
   jps -l
 2) jstack jvm自带堆栈跟踪工具。
   jstack 进程id

23-JUC高并发编程-Callable接口-概述
Runnable和Callable接口
1）是否有返回值
2） 是否拋出异常
3）实现方法名称不同，一个是run方法，一个是call方法

26-JUC高并发编程-辅助类（CountDownLatch)
    减少计数
27-JUC高并发编程-辅助类（CyclicBarrier）
   循环栅栏
   示例：集齐7颗龙珠就可以召唤神龙。
28-JUC高并发编程-辅助类（Semaphore）
29-JUC高并发编程-读写锁-概述
30-JUC高并发编程-读写锁-案例实现
一个资源可以被多个读线程访问，或者可以被一个写线程访问，但是不能同时
存在读写线程。读写互斥，读读共享。
缺点：
1）造成锁饥饿，一直读，没有写操作。
2）读时候，不能写，只有读完之后才能写。

锁降级：将写入锁降级为读锁。读锁不能升级为写锁。
jdk8说明 ：获取写锁->获取读锁->释放写锁->释放读锁

35-JUC高并发编程-阻塞队列-核心方法演示
36-JUC高并发编程-线程池-概述和架构

39-JUC高并发编程-线程池-工作流程和拒绝策略
int corePoolSize,
int maximumPoolSize,
long keepAliveTime,
TimeUnit unit,
BlockingQueue<Runnable> workQueue,
RejectedExecutionHandler handler
任务过来线程池启动corePoolSize个线程执行，新任务超过corePoolSize个时，线程池会把新任务放进workQueue。
当workQueue满了，线程池会开启新线程来跑任务。新加线程的个数最多是(maximumPoolSize-corePoolSize)个。
当队列满了，线程池里的线程数达到maximumPoolSize个了。还有新任务进来就执行handler 拒绝策略。
共有4种拒绝策略
1、AbortPolicy:直接拋出RejectedExecutionException异常阻止系统正常运行。
2、CallerRunsPolicy：调用者运行，一种调节机制，该策略即不会拋弃任务，也不会拋出异常，
    而是将某些任务回退到调用者，从而降低新任务的流量。
3、DiscardOldestPolicy：拋弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务。
4、DiscardPolicy：该策略默默丢弃无法处理的任务，不予任何处理也不拋出异常。
    (如果允许任务丢失，这是最好的一种策略)

40-JUC高并发编程-线程池-自定义线程池
41-JUC高并发编程-分支合并框架-概述
43-JUC高并发编程-异步回调



JUC并发编程与源码分析
03_进程线程管程
04_用户线程和守护线程
05_对Future的改进

 不要阻塞，尽量用轮询替代
 CompletableFuture 实现了 Future和 CompletionStage接口
 提供了非常强大 的Future的扩展功能 。可以帮助我们简化异步编程的复杂性。并且提供 了函数式编程的能力。
CompletionStage代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段。
有点类似linux系统里的管道分隔符。

 CompletableFuture是FutureTask的加强版本。

06_CompletableFuture
07_CompletableFuture四个函数
CompletableFutureDemo.java
异步任务结束时，会自动回调某个对象的方法
异步任务出错时，会自动回调某个对象的方法
主线程设置好回调后，不再关心异步任务的执行，异步任务之间可以顺序执行。

08_get和join方法
join=get ，一样的，区别就是join不拋出异常。

面试的时候面试官想听的项目亮点是：功能 --> 性能。

09_大厂真实案例比价需求
CompletableFutureNetMallDemo.java

11_获得结果和触发计算.mp4

whenComplete和whenCompleteAsync的区别：
whenComplete:是执行当前任务的线程继续执行whenComplete任务。
whenCompleteAsync：是执行把whenCompleteAsync这个任务丢给线程池来执行。

14_从轻松的乐观锁和悲观锁开讲.mp4

悲观锁的调用方式
public synchronized void m1(){
//加锁后的业务逻辑
}
//保证多个线程线程使用的是同一个lock对象的前提下。
ReentrantLock lock = new ReentrantLock();
public void m2(){
     lock.lock();
     try{
        //操作同步资源 。
     }finally{
        lock.unlock();
     }
}

//乐观锁的调用方式 。
//保证多个线程使用的是同一个AtomicInteger
private AtomicInteger atomicInteger = new AtomicInteger();
atomicInteger.incrementAndGet();


16_sync底层字节码.mp4
17_公平锁和非公平锁.mp4
18_可重入锁.mp4
又名递归锁：是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象得是同一个对象)，
不会因为之前已经获取过还没释放而阻塞。
在java中ReentrantLock和synchronized都是可重入锁。
如果不支持可重入锁，程序第2次进入 。被 自己阻塞了岂不是天大的笑话 ，出现了作茧自缚。

每个锁对象拥有一个锁记数器和一个指向持有该 锁的线程的指针。


19_死锁
产生死锁原因
1、系统资源不足
2、进程 运行推进 的顺序不合适
3、资源分配不当。


堆栈分析工具(排查死锁)
查看进程id
jps -l

跟踪java堆栈
jstack 进程id
能看到“Found 1 deadlock” 证明 发生了死锁

查看java堆栈详细信息(推荐)
应用：排查死锁信息
jconsole


20_中断标志面试题.mp4
首先一个线程不应该由其它线程来强制中断或停止，而是应该由线程自己自行停止。
所以，Thread.stop,Thread.suspend,Thread.resume都已经被废弃了。

1、通过一个volatile变量实现
2、通过AtomicBoolean
3、interrupt协商机制

然而停止一个线程又很重要，Java提供了另一种用于停止线程的机制：中断
中断只是一种协作机制，Java没有给中断增加任何语法 ，中断的过程完全需要程序员自己实现。
若要中断一个线程，你需要手动调用该线程的interrupt方法，该 方法也仅仅是将线程对象的中断标识设成true。
接着你需要自己写代码 不断地检测当前线程的标识位，如果为true，表示别的线程要求这条线程中断。

public void interrupt() 设置线程的中断状态为true，不会停止线程。
public static boolean interrupted()判断线程是否被中断，并清除当前中断状态 。
这个方法做了两件事
1）返回当前线程的中断状态
2）将当前线程的中断状态设置为false
public boolean isInterrupted() 判断当前线程是否被 中断(通过检查中断标致位。)


// wait()，join() ,sleep()  methods of this class, then its interrupt status will be cleared and it
// * will receive an {@link InterruptedException}

sleep方法抛出InterruptedException后，中断标识也被清空置为false，
我们在catch没有通过调用Thread.currentThread().interrupt()方法再次将中断标识置为true，
这就导致无限循环了。

22_Object类中的wait和notify方法实现线程等待和唤醒

LockSupport 是用来创建锁和其它同步类的基本线程阻塞原语。
LockSupport中的park()和unpark()的作用分别是阻塞线程和解除阻塞线程。
调用park()会将thread的许可证permit设置成1，多次调用 不会累加。


为什么要用LockSupport?
因为Object和Condition使用的限制条件 。
Object的wait和notify
1) wait和notify必须在synchronized同步代码块里面，且要成对出现,否则报IllegalMonitorStateException
2) 顺序要求是先wait后notify。
Condition
1) Condition中的线程等待和唤醒方法要在锁代码块里(lock和unlock之间)
2) 一定要先await后signal。

25_JMM规范下多线程对变量的读写过程
java memory model 简称jmm
jmm本身是一种抽象的概念并不真实存在它仅仅描述的是一组约定或规范。
关键技术 点都是围绕多线程的原子性，可见性和有序性展开的。
能干嘛？
1）通过jmm实现线程 和主内存之间的抽象关系 。
2） 屏蔽各个硬件平台和操作系统的内存访问差异以实现让java程序在各种平台下
都能达到一致的内存访问效果。



有序性
对于一个线程的执行代码 而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。
但为了提高性能，编译器和处理器通常会对指令序列进行重新排序。
指令重排可以保证串行语义一致，但没有义务保证 多线程间的语义也一致，即可能产生“脏读”，简单说，
两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序 会被优化。
源代码 -> 编译器优化的重排 -> 指令并行的重排 -> 内存系统的重排 -> 最终执行的指令。
单线程环境里面确保程序最终执行结果和代码 顺序执行的结果一致。
处理器在进行重排序时必须要考虑指令之间的数据依赖性
多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定 的，结果无法预测。


Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)
必须在工作内存中进行，首先要将变量从主内存拷贝到线程自己的工作内存空间，然后对变量进行操作，操作完成 后再将变量写回
主内存。不能直接 操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝 。


JMM规范下，多线程先行发生原则之happens-before



www.javaxxz.com_I(*U6y%$refg




jucadvance JUC并发编程与源码分析








