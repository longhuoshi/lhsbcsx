D:\javaxxz\javaEE\【No1417】大厂面试之JUC并发编程与源码分析教程\
jucbase java高级技术JUC高并发编程

多线程操作步骤
1、 创建资源类，在资源类创建属性和方法。
2、在资源类操作方法
    判断->干活->通知 。
3、创建多个线程，调用 资源类中的操作方法。
4、防止虚假唤醒问题。


08-JUC高并发编程-线程间通信-概述和案例分析.mp4
12-JUC高并发编程-线程间定制化通信-案例分析
示例
启动三个线程，按照如下要求
AA打印5次，BB打印10次，CC打印15次
AA打印5次，BB打印10次，CC打印15次
进行10轮

解：
定义 一个标致位flag
1、AA线程 判断flag=1，打印5次。修改标致位flag=2，通知BB
2、BB线程 判断flag=2，打印5次。修改标致位flag=3，通知CC
3、CC线程 判断flag=3，打印5次。修改标致位flag=1，通知AA

13-JUC高并发编程-线程间定制化通信-案例实现
14-JUC高并发编程-集合线程安全-异常演示
16-JUC高并发编程-集合线程安全-ArrayList线程不安全和解决方案（二）
17-JUC高并发编程-集合线程安全-HashSet和HashMap线程不安全
18-JUC高并发编程-多线程锁-Synchronized锁的八种情况
19-JUC高并发编程-多线程锁-公平锁和非公平锁
非公平锁:线程饿死
        效率高
公平锁：阳光普照
       效率相对低。
       new ReentrantLock(true)

21-JUC高并发编程-多线程锁-可重入锁（2）
22-JUC高并发编程-多线程锁-死锁
两个或两个以上的进程(线程)在执行过程中，因为争夺资源而造 成一种互相等待的现象 ，
如果 没有外力干涉，他们无法再执行下去 。
产生死锁原因：
第一 系统资源不足
第二 进程运行推进顺序不合适
第三 资源分配不当。

 验证是否是死锁？
 1) jps  类似linux ps -ef   查看程序对应的进程 id
   jps -l
 2) jstack jvm自带堆栈跟踪工具。
   jstack 进程id

23-JUC高并发编程-Callable接口-概述
Runnable和Callable接口
1）是否有返回值
2） 是否拋出异常
3）实现方法名称不同，一个是run方法，一个是call方法

26-JUC高并发编程-辅助类（CountDownLatch)
    减少计数
27-JUC高并发编程-辅助类（CyclicBarrier）
   循环栅栏
   示例：集齐7颗龙珠就可以召唤神龙。
28-JUC高并发编程-辅助类（Semaphore）
29-JUC高并发编程-读写锁-概述
30-JUC高并发编程-读写锁-案例实现
一个资源可以被多个读线程访问，或者可以被一个写线程访问，但是不能同时
存在读写线程。读写互斥，读读共享。
缺点：
1）造成锁饥饿，一直读，没有写操作。
2）读时候，不能写，只有读完之后才能写。

锁降级：将写入锁降级为读锁。读锁不能升级为写锁。
jdk8说明 ：获取写锁->获取读锁->释放写锁->释放读锁

35-JUC高并发编程-阻塞队列-核心方法演示
36-JUC高并发编程-线程池-概述和架构

39-JUC高并发编程-线程池-工作流程和拒绝策略
int corePoolSize,
int maximumPoolSize,
long keepAliveTime,
TimeUnit unit,
BlockingQueue<Runnable> workQueue,
RejectedExecutionHandler handler
任务过来线程池启动corePoolSize个线程执行，新任务超过corePoolSize个时，线程池会把新任务放进workQueue。
当workQueue满了，线程池会开启新线程来跑任务。新加线程的个数最多是(maximumPoolSize-corePoolSize)个。
当队列满了，线程池里的线程数达到maximumPoolSize个了。还有新任务进来就执行handler 拒绝策略。
共有4种拒绝策略
1、AbortPolicy:直接拋出RejectedExecutionException异常阻止系统正常运行。
2、CallerRunsPolicy：调用者运行，一种调节机制，该策略即不会拋弃任务，也不会拋出异常，
    而是将某些任务回退到调用者，从而降低新任务的流量。
3、DiscardOldestPolicy：拋弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务。
4、DiscardPolicy：该策略默默丢弃无法处理的任务，不予任何处理也不拋出异常。
    (如果允许任务丢失，这是最好的一种策略)

40-JUC高并发编程-线程池-自定义线程池
41-JUC高并发编程-分支合并框架-概述
43-JUC高并发编程-异步回调



JUC并发编程与源码分析
03_进程线程管程
04_用户线程和守护线程
05_对Future的改进

 不要阻塞，尽量用轮询替代
 CompletableFuture 实现了 Future和 CompletionStage接口
 提供了非常强大 的Future的扩展功能 。可以帮助我们简化异步编程的复杂性。并且提供 了函数式编程的能力。
CompletionStage代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段。
有点类似linux系统里的管道分隔符。

 CompletableFuture是FutureTask的加强版本。

06_CompletableFuture
07_CompletableFuture四个函数
CompletableFutureDemo.java
异步任务结束时，会自动回调某个对象的方法
异步任务出错时，会自动回调某个对象的方法
主线程设置好回调后，不再关心异步任务的执行，异步任务之间可以顺序执行。

08_get和join方法
join=get ，一样的，区别就是join不拋出异常。

面试的时候面试官想听的项目亮点是：功能 --> 性能。

09_大厂真实案例比价需求
CompletableFutureNetMallDemo.java

11_获得结果和触发计算.mp4

whenComplete和whenCompleteAsync的区别：
whenComplete:是执行当前任务的线程继续执行whenComplete任务。
whenCompleteAsync：是执行把whenCompleteAsync这个任务丢给线程池来执行。

14_从轻松的乐观锁和悲观锁开讲.mp4

悲观锁的调用方式
public synchronized void m1(){
//加锁后的业务逻辑
}
//保证多个线程线程使用的是同一个lock对象的前提下。
ReentrantLock lock = new ReentrantLock();
public void m2(){
     lock.lock();
     try{
        //操作同步资源 。
     }finally{
        lock.unlock();
     }

}
//乐观锁的调用方式 。
//保证多个线程使用的是同一个AtomicInteger
private AtomicInteger atomicInteger = new AtomicInteger();
atomicInteger.incrementAndGet();


16_sync底层字节码.mp4
17_公平锁和非公平锁.mp4
18_可重入锁.mp4




www.javaxxz.com_I(*U6y%$refg




jucadvance JUC并发编程与源码分析








